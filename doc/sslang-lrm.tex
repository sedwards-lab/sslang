\documentclass{article}
\usepackage{times}

\usepackage{listings}
\usepackage{xcolor}

\definecolor{listingbackground}{rgb}{0.8,0.8,0.8}

\title{SSLANG Language Reference Manual}
\author{Hans Montero, John Hui, and Stephen A. Edwards}
\date{2021}

\lstdefinelanguage{sslang}{
  morekeywords={let,if,then,else,while,after,wait,pipe},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  columns=flexible,
}

\lstset{language=sslang,
  columns=flexible,
  commentstyle={\itshape\color{red}},
  backgroundcolor=\color{listingbackground},
}

\begin{document}

\maketitle

\section{Wish List}

\subsection{Syntax}

\textit{SE:} Minimal punctuation (e.g., print ``hello'' vs. print(``hello'')).
\textit{JH:} I would like to have punctuation for types/operations with special
built-in meaning, e.g., \verb|&| or \verb|*| for references. I'm not opposed to
using parens for function application, but it depends on whether we can have
partial application.

\textit{SE, JH:} Nested comments

\textit{JH:} Single-line comment syntax. I think this makes sense especially for
a whitespace-sensitive language.

\textit{SE, JH:} Indentation-sensitive nesting; keywords start blocks (Haskell-style).

\textit{SE, JH:} User-defined binary operators and precedence levels.

\textit{JH:} some kind of readable, forward-thinking syntax for annotations that
the compiler can take advantage of, e.g., must-inline, dont-inline,
stack-allocate, maybe-unused. Should be less hacky than Haskell's
\verb|{-# LANGUAGE ... #-}| and C/C++'s \verb|#pragma ..| and
\verb|__attribute__((..))|.

\subsubsection{Discussions}

\textit{SE:} What should function definitions (type signatures) look like?
Haskell-style or OCaml-style?  Look at the Nim language.  Named arguments?  Make
it look like data constructors?
\textit{JH:} Should be OCaml-style, in that it is inline, but it should not look
so ugly. Whatever syntax we use, declaration for follow invocation.

\begin{itemize}
  \item OCaml uses something like: \verb|f (a: int) (b: int) = ..|. Too many
    parentheses.
  \item In our meeting, we threw around the idea of something like: \verb|f a:
    Int, b: Int = ..|. \textit{JH:} seems fine, but looks weird because comma
    precedence is not widely understood.
  \item Rust, Go, Javascript, and other recent languages use: \verb|f(a: Int, b: Int) .. |.
    \textit{JH:} I don't love it, but I don't hate it either, and it's familiar.
\end{itemize}

\subsection{Types and expressions}

\textit{SE, JH:} Type expressions.

\textit{SE, JH:} Algebraic data types + patter-matching.

Statically sized arrays passable through abstract array arguments, e.g., so you
can write a sort that's polymorphic in the size of the array; implies array size
is a runtime value, not (just) compile-time.

\textit{SE, JH:} Typeclasses at least for arithmetic operators

Pass-by-value and pass-by-reference values

\textit{JH:} References to arrays of T, arrays of arrays of T

\textit{JH, SE:} Array slices (``safe'' references to parts of arrays that play
well with parallelism)

\textit{SE, JH:} Type inference at least for local variables

\textit{JH:} Type annotations for function arguments

\textit{SE, JH:} Parametric polymorphism, likely eliminated by whole-program
monomorphisation (type variables)

\textit{SE, JH:} A notion of constants (assign once) versus variables (assign
multiple times)

\textit{JH:} a notion of ownership that users can opt into (which reduces to
reference-sharing otherwise).

\subsubsection{Discussions}

\textit{SE, JH:} Partial application?  Or do we prohibit it?

\subsection{Control flow}

\textit{SE, JH:} Parallel function calls.

\textit{JH:} Some sort of exception handling.

\textit{SE, JH:} Wait on variables

\textit{SE, JH:} Immediate and delayed assignment ``primitives''

\subsection{Generated code}

\textit{SE, JH:} Compile-time allocation of all data (exception: activation records)

\textit{SE, JH:} Facility for efficient code generation with compile-time
constants (should this be syntactically different?).

\section{Overview}

\begin{lstlisting}
main(led : Ref (Sched Bool) ) =
  loop
    after 50 ms, led <- True
    wait led
    after 50 ms, led <- False
    wait led
\end{lstlisting}

\begin{lstlisting}
toggle(led : Ref (Sched Bool)) =
  led <- not led

slow(led : Ref (Sched Bool)) =
  let e1 = Occur : Sched Event
  loop
    toggle led
    after 30 ms, e1 <- Occur
    wait e1

fast(led : Ref (Sched Bool)) =
  let e2 = Occur : Sched Event
  loop
    toggle led
    after 20 ms, e2 <- Occur
    wait e2
    
main(led : Ref (Sched Bool)) =
  pipe slow led
       fast led
\end{lstlisting}

\section{Lexical Conventions}

\subsection{Comments}

Single line comments start with \lstinline!//! and end at a newline.

Multi-line comments start with \lstinline!/*! and end at a matching
\lstinline!*/!.  Multi-line comments nest and may also include
single-line comments.

\subsection{Indentation and Grouping}

\subsection{Lexer States}

\begin{itemize}

\item Freeform: The scanner discards whitespace and does not insert
  grouping tokens
  
\item InBlock: The scanner is in a block; a separator is inserted in
  front of each line that starts at the current indentation level.  A
  line that starts to the left of the current indentation level causes
  a close-block token to be inserted (i.e., \lstinline!}!) and the
    current state to be popped.
    
\item StartBlock: The scanner will start a block (insert a
  \lstinline!{!) at the start of the next token and enter the InBlock
    state
    
\item StartBlockNL: The scanner will start a block (insert a
  \lstinline!{!) at the token that starts the next line and enter the InBlock
    state

\end{itemize}

\section{Types}

\section{Expressions}

\end{document}
